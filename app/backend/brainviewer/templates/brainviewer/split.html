<!DOCTYPE html>
<html lang="en" style="height: 100%">
  <head>
    <meta charset="UTF-8" />
    <title>{{ title }}</title>
    {# Dynamic title, should be set by backend e.g., "Viewer - B:222 S:1000" #}
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v5.3.0/css/ol.css"
      type="text/css"
    />
    <style>
      html, body { 
        margin: 0; 
        padding: 0; 
        overflow: hidden; 
        height: 100%; 
        width: 100%; 
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        background-color: #f8fafc;
      }
      .main-container { width: 100%; height: 100%; position: relative; }

      /* Default: JP2 Fullscreen, BFI Thumbnail */
      #jp2_map {
          width: 100%;
          height: 100%;
          background-color: #f0f0f0;
          position: relative;
      }

      /* BFI Thumbnail Styling (when JP2 is fullscreen) */
      .bfi-thumbnail-container:not(.fullscreen-mode) {
          position: absolute;
          bottom: 16px;
          right: 16px;
          width: 280px;
          height: 200px;
          border: 1px solid rgba(0, 0, 0, 0.15);
          border-radius: 8px;
          box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
          z-index: 1001;
          background-color: white;
          overflow: hidden;
          transition: all 0.3s ease;
      }
      
      .bfi-thumbnail-container:not(.fullscreen-mode):hover {
          box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
          transform: translateY(-2px);
      }

      .bfi-thumbnail-container:not(.fullscreen-mode) .bfi-image-viewport {
          position: absolute;
          width: 160%;         /* Make the image viewport larger than its container */
          height: 160%;        /* Make the image viewport larger than its container */
          left: 50%;           /* Center horizontally */
          top: 50%;            /* Center vertically */
          transform: translate(-60%, -60%); /* Adjust for centering */
      }

      .bfi-thumbnail-container:not(.fullscreen-mode) #bfi_thumbnail_img {
          display: none; /* Always hide the img tag when using OL map */
      }

      .bfi-thumbnail-container:not(.fullscreen-mode) .bfi-overlay {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          pointer-events: none; /* OL map handles interactions */
      }

      /* BFI Fullscreen Styling */
      .bfi-thumbnail-container.fullscreen-mode {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          border: none;
          box-shadow: none;
          z-index: 1000;
          overflow: visible;
      }

      .bfi-thumbnail-container.fullscreen-mode .bfi-image-viewport {
          position: static;
          width: 100%;
          height: 100%;
          transform: none;
      }

      .bfi-thumbnail-container.fullscreen-mode #bfi_thumbnail_img {
          width: 100%;
          height: 100%;
          object-fit: contain;
      }

      .bfi-thumbnail-container.fullscreen-mode .bfi-overlay {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          pointer-events: none; /* OL map handles interactions */
      }

      /* Switched: JP2 Thumbnail, BFI Fullscreen */
      #jp2_map.thumbnail-mode {
          position: absolute;
          top: 16px;
          right: 16px;
          width: 320px;
          height: 240px;
          border: 1px solid rgba(0, 0, 0, 0.15);
          border-radius: 8px;
          box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
          z-index: 1001;
          transition: all 0.3s ease;
      }
      
      #jp2_map.thumbnail-mode:hover {
          box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
          transform: translateY(-2px);
      }
      #jp2_map.thumbnail-mode .ol-zoomslider {
          display: none;
      }

      .coordinates { 
        position: absolute; 
        bottom: 12px; 
        left: 12px; 
        background-color: rgba(0, 0, 0, 0.8); 
        color: white; 
        padding: 6px 12px; 
        border-radius: 6px; 
        font-size: 12px; 
        font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
        z-index: 1000; 
        backdrop-filter: blur(4px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      }
      #bfi_target_coordinates { bottom: 48px; }
      #jp2_target_coordinates { bottom: 84px; }

      .bfi-thumbnail-container .caption { 
        font-size: 11px; 
        text-align: center; 
        padding: 4px 6px; 
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(248, 250, 252, 0.9)); 
        color: #374151; 
        position: absolute; 
        bottom: 0; 
        left: 0; 
        width: 100%; 
        box-sizing: border-box;
        border-top: 1px solid rgba(0, 0, 0, 0.1);
        font-weight: 500;
        letter-spacing: 0.3px;
      }
      .bfi-overlay .pointer-lines { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;}
      .bfi-overlay .vline, .bfi-overlay .hline { 
        position: absolute; 
        background: #3B82F6; 
        display: none; 
        pointer-events: none;
        box-shadow: 0 0 3px rgba(59, 130, 246, 0.5);
      }
      .bfi-overlay .vline { width: 1px; height: 100%; top: 0; }
      .bfi-overlay .hline { height: 1px; width: 100%; left: 0; }

      .test-marker-bfi {
          position: absolute;
          width: 8px; 
          height: 8px; 
          background-color: #10B981; 
          border: 2px solid #fff;
          border-radius: 50%;
          transform: translate(-50%, -50%);
          z-index: 10;
          pointer-events: none;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      #bfi_view_rect {
          position: absolute;
          border: 1.5px solid red;
          background-color: transparent;
          pointer-events: auto;
          cursor: grab;
          z-index: 5; /* This DOM element is no longer used for the view rect */
          display: none;
      }

      /* Controls styling */
      #controls {
          position: fixed;
          top: 12px;
          left: 12px;
          z-index: 2000;
          background: rgba(255, 255, 255, 0.95);
          padding: 10px 16px;
          border-radius: 8px;
          box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
          backdrop-filter: blur(10px);
          border: 1px solid rgba(0, 0, 0, 0.1);
          display: flex;
          gap: 20px;
          align-items: center;
      }
      #controls label {
          margin-right: 8px;
          font-size: 14px;
          font-weight: 500;
          color: #374151;
      }
      #controls select {
          padding: 6px 10px;
          border-radius: 6px;
          border: 1px solid rgba(0, 0, 0, 0.15);
          font-size: 14px;
          background: white;
          color: #374151;
          transition: border-color 0.2s ease;
      }
      #controls select:focus {
          outline: none;
          border-color: #3B82F6;
          box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
      }
      .button-stack {
          position: fixed;
          top: 72px;
          left: 12px;
          z-index: 2000;
          display: flex;
          flex-direction: column;
          gap: 8px;
      }


      #switchViewBtn, #splitViewBtn {
          padding: 10px 16px;
          background-color: #3B82F6;
          color: white;
          border: none;
          border-radius: 6px;
          cursor: pointer;
          font-size: 14px;
          font-weight: 500;
          transition: all 0.2s ease;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      #switchViewBtn:hover, #splitViewBtn:hover {
          background-color: #2563EB;
          transform: translateY(-1px);
          box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
      }
      .split-left {
          /* optional: add styles if needed */

      }

      .split-right {
          /* optional: add styles if needed */
      }

      .bfi-thumbnail-container:not(.fullscreen-mode) .bfi-image-viewport,
      #jp2_map.thumbnail-mode {
          /* Ensure the map/image fits the container */
          overflow: hidden;
      }
      .split-mode-overlay {
        position: absolute;
        top: 12px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 2001;
        display: none;
        background: rgba(255, 255, 255, 0.95);
        padding: 12px;
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .split-mode-overlay.active {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .split-mode-overlay div {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .split-mode-overlay label {
            font-size: 12px;
            font-weight: 500;
            color: #374151;
            margin: 0;
        }

        .image-selector {
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid rgba(0, 0, 0, 0.15);
            font-size: 13px;
            background: white;
            color: #374151;
            transition: border-color 0.2s ease;
            min-width: 100px;
        }

        .image-selector:focus {
            outline: none;
            border-color: #3B82F6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        .header{
            margin: 0;
            padding: 8px 15px;
            color: #333;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: rgba(255, 255, 255, 0.95);
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            position: relative;
            z-index: 100;
        }

        .header p{
            margin: 0;
            font-size: 14px;
            font-weight: 500;
            letter-spacing: 0.5px;
        }
        
        /* Vertical Navigation Sidebar */
        .nav-sidebar {
            position: fixed;
            left: 0;
            top: 0;
            width: 60px;
            height: 100vh;
            background: rgba(30, 30, 30, 0.95);
            backdrop-filter: blur(10px);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px 0;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
        }
        
        .nav-button {
            width: 40px;
            height: 40px;
            margin: 10px 0;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .nav-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(5px);
        }
        
        .nav-button.active {
            background: #3B82F6;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }
        
        .nav-tooltip {
            position: absolute;
            left: 50px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .nav-button:hover .nav-tooltip {
            opacity: 1;
        }
        
        /* RGB Control Panel - Slide from left */
        .rgb-control-panel {
            position: fixed;
            left: -350px;
            top: 0;
            width: 320px;
            height: 100vh;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(15px);
            z-index: 9999;
            padding: 80px 20px 20px 80px;
            box-shadow: 2px 0 20px rgba(0, 0, 0, 0.2);
            transition: left 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            overflow-y: auto;
            border-right: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        .rgb-control-panel.visible {
            left: 0;
        }
        
        .rgb-control-panel h3 {
            margin: 0 0 20px 0;
            font-size: 18px;
            font-weight: 600;
            color: #333;
            border-bottom: 2px solid #3B82F6;
            padding-bottom: 10px;
        }
        
        .image-control-group {
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(248, 250, 252, 0.8);
            border-radius: 12px;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
        
        .image-control-group h4 {
            margin: 0 0 15px 0;
            font-size: 16px;
            font-weight: 600;
            color: #333;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #10B981;
        }
        
        .slider-group {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .slider-group label {
            min-width: 80px;
            font-size: 14px;
            font-weight: 500;
            color: #555;
        }
        
        .channel-label {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .channel-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        
        .channel-color.red { background: #EF4444; }
        .channel-color.green { background: #10B981; }
        .channel-color.blue { background: #3B82F6; }
        
        .opacity-slider {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(to right, #E5E7EB, #9CA3AF);
            outline: none;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .opacity-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #3B82F6;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.4);
            transition: all 0.2s ease;
        }
        
        .opacity-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.6);
        }
        
        .opacity-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #3B82F6;
            cursor: pointer;
            border-radius: 50%;
            border: none;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.4);
        }
        
        .slider-value {
            min-width: 45px;
            text-align: right;
            font-weight: 600;
            color: #374151;
        }
        
        /* Reset button for each image group */
        .reset-button {
            width: 100%;
            padding: 8px 16px;
            background: rgba(107, 114, 128, 0.1);
            border: 1px solid rgba(107, 114, 128, 0.3);
            border-radius: 6px;
            color: #374151;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s ease;
            margin-top: 10px;
        }
        
        .reset-button:hover {
            background: rgba(107, 114, 128, 0.2);
            border-color: rgba(107, 114, 128, 0.5);
        }
        
        /* Gamma correction specific styles */
        .gamma-control {
            border-top: 1px solid rgba(0, 0, 0, 0.1);
            padding-top: 15px;
            margin-top: 10px;
        }
        
        .gamma-icon {
            width: 12px;
            height: 12px;
            background: linear-gradient(45deg, #8B5CF6, #A78BFA);
            color: white;
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
        }
        
        .gamma-slider {
            background: linear-gradient(to right, #F3E8FF, #8B5CF6);
        }
        
        .gamma-slider::-webkit-slider-thumb {
            background: #8B5CF6;
            box-shadow: 0 2px 8px rgba(139, 92, 246, 0.4);
        }
        
        .gamma-slider::-webkit-slider-thumb:hover {
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.6);
        }
        
        .gamma-slider::-moz-range-thumb {
            background: #8B5CF6;
            box-shadow: 0 2px 8px rgba(139, 92, 246, 0.4);
        }
        
    </style>
    <script src="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v5.3.0/build/ol.js"></script>
  </head>
  <body style="height: 100%">
    <!-- Vertical Navigation Sidebar -->
    <div class="nav-sidebar">
      <button class="nav-button" id="rgbControlBtn">
        🎨
        <div class="nav-tooltip">RGB Controls</div>
      </button>
    </div>

    <!-- RGB Control Panel -->
    <div class="rgb-control-panel" id="rgbControlPanel">
      <h3>RGB Opacity Controls</h3>
      
      <!-- JP2 Image Controls -->
      <div class="image-control-group">
        <h4>
          <div class="status-indicator"></div>
          JP2 Image (Nissl/Hae)
        </h4>
        <div class="slider-group">
          <label class="channel-label">
            <div class="channel-color red"></div>
            Red:
          </label>
          <input type="range" id="jp2-r-slider" min="0" max="100" value="100" class="opacity-slider">
          <span class="slider-value" id="jp2-r-value">100%</span>
        </div>
        <div class="slider-group">
          <label class="channel-label">
            <div class="channel-color green"></div>
            Green:
          </label>
          <input type="range" id="jp2-g-slider" min="0" max="100" value="100" class="opacity-slider">
          <span class="slider-value" id="jp2-g-value">100%</span>
        </div>
        <div class="slider-group">
          <label class="channel-label">
            <div class="channel-color blue"></div>
            Blue:
          </label>
          <input type="range" id="jp2-b-slider" min="0" max="100" value="100" class="opacity-slider">
          <span class="slider-value" id="jp2-b-value">100%</span>
        </div>
        <div class="slider-group gamma-control">
          <label class="channel-label">
            <div class="gamma-icon">γ</div>
            Gamma:
          </label>
          <input type="range" id="jp2-gamma-slider" min="10" max="300" value="100" class="opacity-slider gamma-slider">
          <span class="slider-value" id="jp2-gamma-value">1.0</span>
        </div>
        <button class="reset-button" onclick="resetJP2RGB()">Reset JP2 RGB</button>
      </div>

      <!-- BFI Image Controls -->
      <div class="image-control-group">
        <h4>
          <div class="status-indicator"></div>
          BFI Image (BFI/MRI)
        </h4>
        <div class="slider-group">
          <label class="channel-label">
            <div class="channel-color red"></div>
            Red:
          </label>
          <input type="range" id="bfi-r-slider" min="0" max="100" value="100" class="opacity-slider">
          <span class="slider-value" id="bfi-r-value">100%</span>
        </div>
        <div class="slider-group">
          <label class="channel-label">
            <div class="channel-color green"></div>
            Green:
          </label>
          <input type="range" id="bfi-g-slider" min="0" max="100" value="100" class="opacity-slider">
          <span class="slider-value" id="bfi-g-value">100%</span>
        </div>
        <div class="slider-group">
          <label class="channel-label">
            <div class="channel-color blue"></div>
            Blue:
          </label>
          <input type="range" id="bfi-b-slider" min="0" max="100" value="100" class="opacity-slider">
          <span class="slider-value" id="bfi-b-value">100%</span>
        </div>
        <div class="slider-group gamma-control">
          <label class="channel-label">
            <div class="gamma-icon">γ</div>
            Gamma:
          </label>
          <input type="range" id="bfi-gamma-slider" min="10" max="300" value="100" class="opacity-slider gamma-slider">
          <span class="slider-value" id="bfi-gamma-value">1.0</span>
        </div>
        <button class="reset-button" onclick="resetBFIRGB()">Reset BFI RGB</button>
      </div>

      <!-- Combined Controls -->
      <div class="image-control-group">
        <h4>
          <div class="status-indicator"></div>
          Both Images (Synchronized)
        </h4>
        <div class="slider-group">
          <label class="channel-label">
            <div class="channel-color red"></div>
            Red:
          </label>
          <input type="range" id="combined-r-slider" min="0" max="100" value="100" class="opacity-slider">
          <span class="slider-value" id="combined-r-value">100%</span>
        </div>
        <div class="slider-group">
          <label class="channel-label">
            <div class="channel-color green"></div>
            Green:
          </label>
          <input type="range" id="combined-g-slider" min="0" max="100" value="100" class="opacity-slider">
          <span class="slider-value" id="combined-g-value">100%</span>
        </div>
        <div class="slider-group">
          <label class="channel-label">
            <div class="channel-color blue"></div>
            Blue:
          </label>
          <input type="range" id="combined-b-slider" min="0" max="100" value="100" class="opacity-slider">
          <span class="slider-value" id="combined-b-value">100%</span>
        </div>
        <div class="slider-group gamma-control">
          <label class="channel-label">
            <div class="gamma-icon">γ</div>
            Gamma:
          </label>
          <input type="range" id="combined-gamma-slider" min="10" max="300" value="100" class="opacity-slider gamma-slider">
          <span class="slider-value" id="combined-gamma-value">1.0</span>
        </div>
        <button class="reset-button" onclick="resetAllRGB()">Reset All RGB</button>
      </div>
    </div>

    <!--
    <div class="header">
        <p>BFI tracker Biosample: {{ current_biosample_id }} Section: {{ current_slice_number }}</p>
    </div>
    <div id="controls" >
    -->
    <div id="controls" style="display: none" > 
      <div>
        <label for="biosampleIdSelect">Biosample ID:</label>
        <select id="biosampleIdSelect">
          <!-- Options populated by JS -->
        </select>
      </div>
      <div>
        <label for="sliceNumberSelect">Slice Number:</label>
        <select id="sliceNumberSelect">
          <!-- Options populated by JS -->
        </select>
      </div>
    </div>
    <div class="button-stack" style="display: none" >
      <button id="switchViewBtn" style="display: none">View BFI Fullscreen</button>
      <button id="splitViewBtn" style="display: none">Split View</button>
    </div>
    <div class="split-mode-overlay" id="splitModeOverlay" >
      <div>
        <label for="jp2ImageSelect">Image:</label>
        <select id="jp2ImageSelect" class="image-selector">
          <option value="original">Nissl</option>
          <option value="nissl">Hae</option>
        </select>
      </div>
      <div>
        <label for="bfiImageSelect">Image:</label>
        <select id="bfiImageSelect" class="image-selector">
          <option value="original">BFI</option>
          <option value="mri">MRI</option>
        </select>
      </div>
    </div>
    

    <div class="main-container">
      <div id="jp2_map"></div>
      <div id="mouse_coordinates" class="coordinates" style="display: none">JP2 Mouse: N/A</div>
      <div id="bfi_target_coordinates" class="coordinates" style="bottom: 30px;display: none">
        BFI Target: N/A
      </div>
      <div id="jp2_target_coordinates" class="coordinates" style="bottom: 50px;display: none">
        JP2 Target: N/A
      </div>

      <div class="bfi-thumbnail-container" id="bfi_thumb_wrap">
        <div class="bfi-image-viewport" id="bfi_image_viewport_el">
          <div
            id="bfi_ol_map"
            style="width: 100%; height: 100%; display: none"
          ></div>
          <img
            id="bfi_thumbnail_img"
            src=""
            alt="BFI Thumbnail"
            style="display: none"
          />
          <div class="bfi-overlay" id="bfi_thumb_overlay">
            <div id="bfi_view_rect"></div>
            <div class="pointer-lines" id="bfi_hover_crosshair">
              <div class="vline"></div>
              <div class="hline"></div>
            </div>
          </div>
        </div>
        <div class="caption">BFI Slice (Rotated)</div>
      </div>
    </div>

    <script type="text/javascript">
              // --- Data injected by Flask/backend ---
              const jp2MapUrl = {{ jp2_map_url | safe}};
              const jp2FullSize = {{ jp2_full_size | safe}};
              const jp2InitialViewRotationDeg = {{ jp2_initial_view_rotation_deg | safe}};

              const bfiImageUrl = {{ bfi_image_url | safe}};
              const bfiCssRotationDeg = {{ bfi_css_rotation_deg | safe}};
              let bfiNaturalWidth = 0;
              let bfiNaturalHeight = 0;
              let bfiLoaded = false;

              const H_jp2_to_bfi = {{ h_jp2_to_bfi | safe}};
              let H_bfi_to_jp2 = null;


              const mriImageUrl = {{ mri_image_url | safe}};
              const mriFullSize = {{ mri_full_size | safe}};
              const mriInitialViewRotationDeg = {{ mri_initial_view_rotation_deg | safe}};

              const nisslImageUrl = {{ nissl_image_url | safe}};
              const nisslFullSize = {{ nissl_full_size | safe}};
              const nisslInitialViewRotationDeg = {{ nissl_initial_view_rotation_deg | safe}};

              const testPointsJP2 = {{ test_points_jp2  | safe}};

              // --- Data for dropdowns and navigation ---
              const currentBiosampleId = {{ current_biosample_id | safe}};
              const currentSliceNumber = {{ current_slice_number | safe}}; // Ensure this is a string if values are strings
              const availableBiosampleIds = {{ available_biosample_ids | safe}};
              const availableSliceNumbers = {{ available_slice_numbers  | safe}};
              const viewerUrlTemplate = {{ viewer_url_template | safe}}; // e.g., "/viewer/__BID__/__SID__"

              //console.log("--- Frontend Data Received ---");
              //console.log("JP2 Map URL:", jp2MapUrl);
              //console.log("Current Biosample ID:", currentBiosampleId);
              //console.log("Current Slice Number:", currentSliceNumber);
              //console.log("Available Biosample IDs:", availableBiosampleIds);
              //console.log("Available Slice Numbers:", availableSliceNumbers);
              //console.log("Viewer URL Template:", viewerUrlTemplate);

              //console.log("mriImageUrl",mriImageUrl)
              //console.log("nisslImageUrl",nisslImageUrl)


              // --- DOM Elements ---
              const mapElement = document.getElementById('jp2_map');
              const coordinatesDisplay = document.getElementById('mouse_coordinates');
              const bfiTargetCoordinatesDisplay = document.getElementById('bfi_target_coordinates');
              const jp2TargetCoordinatesDisplay = document.getElementById('jp2_target_coordinates');
              const bfiThumbnailContainer = document.getElementById('bfi_thumb_wrap');
              const bfiThumbnailImg = document.getElementById('bfi_thumbnail_img');
              const bfiThumbOverlay = document.getElementById('bfi_thumb_overlay');
              const bfiHoverCrosshairLines = document.getElementById('bfi_hover_crosshair');
              const bfiViewRect = document.getElementById('bfi_view_rect');
              const switchViewBtn = document.getElementById('switchViewBtn');
              // Send the message to the parent
              const coordinates = jp2TargetCoordinatesDisplay.textContent
              window.parent.postMessage(
                  { type: 'jp2_coordinates', coordinates: coordinates },
                  '*'
              );
              // Dropdown elements
              const biosampleIdSelect = document.getElementById('biosampleIdSelect');
              const sliceNumberSelect = document.getElementById('sliceNumberSelect');

              // --- OL Map Variables ---
              var olMap; // JP2 OpenLayers map instance
              var bfiOlMap = null; // Global variable for BFI OpenLayers map
              var bfiView = null; // Global variable for BFI OpenLayers view
              var bfiTestMarkerLayer = null; // Global variable for BFI test marker layer
              var bfiHoverMarkerLayer = null;
              var bfiViewRectLayer = null; // For the JP2 view rectangle on the BFI map

              let view;
              let jp2TestMarkerLayer;
              let jp2HoverMarkerLayer;

              // --- State Variables ---
              let isDraggingBFIRect = false;
              let bfiViewRectDragOffset = { x: 0, y: 0 };
              let jp2IsFullscreen = true;

              // --- Core Functions (invertAffineMatrix, applyHomography, coordinate transformations, drawing, etc.) ---
              // ... (These functions remain unchanged from your previous working version) ...
              function invertAffineMatrix(H) {
                  if (!H || H.length < 2 || H[0].length < 3 || H[1].length < 3 ) {
                      console.error("Invalid matrix H for inversion:", H);
                      return null;
                  }
                  const a = H[0][0], b = H[0][1], tx = H[0][2];
                  const c = H[1][0], d = H[1][1], ty = H[1][2];
                  const det = a * d - b * c;
                  if (Math.abs(det) < 1e-7) {
                      console.error("Matrix determinant is near zero, cannot invert.", det, H);
                      return null;
                  }
                  const invDet = 1.0 / det;
                  return [
                      [invDet * d, invDet * -b, invDet * (b * ty - d * tx)],
                      [invDet * -c, invDet * a,  invDet * (c * tx - a * ty)],
                      [0, 0, 1]
                  ];
              }

              function applyHomography(point, H) {
                   if (!H || H.length < 3 || H[0].length < 3 || H[1].length < 3 || H[2].length < 3) {
                       console.error("Invalid matrix H for applyHomography:", H); return null;
                  }
                  const x = point[0], y = point[1];
                  const W = H[2][0] * x + H[2][1] * y + H[2][2];
                  if (Math.abs(W) < 1e-7) { console.warn("Homography denominator W is near zero for point:", point, " H:", H); return null; }
                  const tx = (H[0][0] * x + H[0][1] * y + H[0][2]) / W;
                  const ty = (H[1][0] * x + H[1][1] * y + H[1][2]) / W;
                  return [tx, ty];
              }

              function getBfiDisplayCoordsFromNatural(bfiX_nat, bfiY_nat) {
                  if (!bfiLoaded || !bfiNaturalWidth || !bfiNaturalHeight) return null;

                  const imgElement = bfiThumbnailImg; // This function is mostly for legacy DOM drawing, will be replaced by OL
                  const imgBoxWidth = imgElement.clientWidth;
                  const imgBoxHeight = imgElement.clientHeight;

                  if (imgBoxWidth <= 0 || imgBoxHeight <= 0) return null;

                  let scale;
                  let contentOffsetXInBox = 0, contentOffsetYInBox = 0;

                  if (bfiThumbnailContainer.classList.contains('fullscreen-mode')) {
                      const natAspect = bfiNaturalWidth / bfiNaturalHeight;
                      const boxAspectForObjectFit = imgBoxWidth / imgBoxHeight;

                      if (natAspect > boxAspectForObjectFit) {
                          scale = imgBoxWidth / bfiNaturalWidth;
                          contentOffsetYInBox = (imgBoxHeight - (bfiNaturalHeight * scale)) / 2;
                      } else {
                          scale = imgBoxHeight / bfiNaturalHeight;
                          contentOffsetXInBox = (imgBoxWidth - (bfiNaturalWidth * scale)) / 2;
                      }
                  } else {
                      scale = imgBoxWidth / bfiNaturalWidth;
                  }

                  const x_scaled_content = bfiX_nat * scale;
                  const y_scaled_content = bfiY_nat * scale;

                  const x_in_imgBox_unrotated = x_scaled_content + contentOffsetXInBox;
                  const y_in_imgBox_unrotated = y_scaled_content + contentOffsetYInBox;

                  const centerX_imgBox = imgBoxWidth / 2;
                  const centerY_imgBox = imgBoxHeight / 2;

                  const x_rel_center_unrotated = x_in_imgBox_unrotated - centerX_imgBox;
                  const y_rel_center_unrotated = y_in_imgBox_unrotated - centerY_imgBox;

                  const angleRad = bfiCssRotationDeg * Math.PI / 180;
                  const cosA = Math.cos(angleRad);
                  const sinA = Math.sin(angleRad);

                  const x_rel_center_rotated = x_rel_center_unrotated * cosA - y_rel_center_unrotated * sinA;
                  const y_rel_center_rotated = x_rel_center_unrotated * sinA + y_rel_center_unrotated * cosA;

                  const finalX_on_overlay = x_rel_center_rotated + centerX_imgBox;
                  const finalY_on_overlay = y_rel_center_rotated + centerY_imgBox;

                  return { x: finalX_on_overlay, y: finalY_on_overlay };
              }

              function getBFIMouseRelatedCoords(event, relativeToElement /* bfiThumbOverlay */) {
                  if (!bfiLoaded || !bfiNaturalWidth || !bfiNaturalHeight) return null;

                  const imgElement = bfiThumbnailImg; // This function is mostly for legacy DOM drawing, will be replaced by OL
                  const overlayElement = relativeToElement;

                  const overlayRect = overlayElement.getBoundingClientRect();
                  const mouseX_on_overlay = event.clientX - overlayRect.left;
                  const mouseY_on_overlay = event.clientY - overlayRect.top;

                  const imgBoxWidth = imgElement.clientWidth;
                  const imgBoxHeight = imgElement.clientHeight;

                  if (imgBoxWidth <= 0 || imgBoxHeight <= 0) return null;

                  const centerX_imgBox = imgBoxWidth / 2;
                  const centerY_imgBox = imgBoxHeight / 2;

                  const mouseX_rel_center_imgBox = mouseX_on_overlay - centerX_imgBox;
                  const mouseY_rel_center_imgBox = mouseY_on_overlay - centerY_imgBox;

                  const angleRad = -bfiCssRotationDeg * Math.PI / 180;
                  const cosA = Math.cos(angleRad);
                  const sinA = Math.sin(angleRad);

                  const unrotated_X_rel_center_imgBox = mouseX_rel_center_imgBox * cosA - mouseY_rel_center_imgBox * sinA;
                  const unrotated_Y_rel_center_imgBox = mouseX_rel_center_imgBox * sinA + mouseY_rel_center_imgBox * cosA;

                  const mouseX_in_imgBox_unrotated = unrotated_X_rel_center_imgBox + centerX_imgBox;
                  const mouseY_in_imgBox_unrotated = unrotated_Y_rel_center_imgBox + centerY_imgBox;

                  let scale;
                  let contentOffsetXInBox = 0, contentOffsetYInBox = 0;

                  if (bfiThumbnailContainer.classList.contains('fullscreen-mode')) {
                      const natAspect = bfiNaturalWidth / bfiNaturalHeight;
                      const boxAspectForObjectFit = imgBoxWidth / imgBoxHeight;
                      if (natAspect > boxAspectForObjectFit) {
                          scale = imgBoxWidth / bfiNaturalWidth;
                          contentOffsetYInBox = (imgBoxHeight - (bfiNaturalHeight * scale)) / 2;
                      } else {
                          scale = imgBoxHeight / bfiNaturalHeight;
                          contentOffsetXInBox = (imgBoxWidth - (bfiNaturalWidth * scale)) / 2;
                      }
                  } else {
                      scale = imgBoxWidth / bfiNaturalWidth;
                  }

                  if (Math.abs(scale) < 1e-7) return null;

                  const x_in_scaled_content = mouseX_in_imgBox_unrotated - contentOffsetXInBox;
                  const y_in_scaled_content = mouseY_in_imgBox_unrotated - contentOffsetYInBox;

                  const bfiX_nat = x_in_scaled_content / scale;
                  const bfiY_nat = y_in_scaled_content / scale;

                  return {
                      mouseX_relative: mouseX_on_overlay,
                      mouseY_relative: mouseY_on_overlay,
                      bfiX_nat,
                      bfiY_nat
                  };
              }

              function drawOnBFIOverlay(bfiX_nat, bfiY_nat, isFixedMarker = false, targetElement = null) {
                  // This function is for drawing on the old DOM-based BFI overlay. It will be replaced by OL drawing.
                  const displayCoords = getBfiDisplayCoordsFromNatural(bfiX_nat, bfiY_nat);
                  if (!displayCoords) {
                      if (!isFixedMarker && targetElement) hideCrosshairOnBFI(targetElement);
                      return;
                  }
                  const { x: displayX, y: displayY } = displayCoords;

                  const overlayW = bfiThumbOverlay.clientWidth;
                  const overlayH = bfiThumbOverlay.clientHeight;
                  const tolerance = 1;
                  if (displayX < -tolerance || displayX > overlayW + tolerance || displayY < -tolerance || displayY > overlayH + tolerance) {
                       if (!isFixedMarker && targetElement) hideCrosshairOnBFI(targetElement);
                      return;
                  }

                  if (!isFixedMarker) {
                      const crosshairTarget = targetElement || bfiHoverCrosshairLines;
                      const vLine = crosshairTarget.querySelector('.vline');
                      const hLine = crosshairTarget.querySelector('.hline');
                      bfiTargetCoordinatesDisplay.textContent = `BFI Target: Nat(${bfiX_nat.toFixed(0)}, ${bfiY_nat.toFixed(0)})`;
                      vLine.style.left = `${displayX}px`;
                      hLine.style.top = `${displayY}px`;
                      vLine.style.display = 'block';
                      hLine.style.display = 'block';
                  } else {
                      const bfiMarker = document.createElement('div');
                      bfiMarker.className = 'test-marker-bfi';
                      bfiMarker.style.left = `${displayX}px`;
                      bfiMarker.style.top = `${displayY}px`;
                      bfiThumbOverlay.appendChild(bfiMarker);
                  }
              }

              function hideCrosshairOnBFI(crosshairElem) {
                  // This function is for hiding crosshairs on the old DOM-based BFI overlay.
                  const targetElem = crosshairElem || bfiHoverCrosshairLines;
                  const vLine = targetElem.querySelector('.vline');
                  const hLine = targetElem.querySelector('.hline');
                  if (vLine) vLine.style.display = 'none';
                  if (hLine) hLine.style.display = 'none';
                  if (targetElem === bfiHoverCrosshairLines) {
                       bfiTargetCoordinatesDisplay.textContent = "BFI Target: N/A";
                  }
              }

              function drawMarkerOnJP2(jp2X_img, jp2Y_img, isHoverMarker = false) {
                  //console.log('drawMarkerOnJP2 called:', jp2X_img, jp2Y_img, isHoverMarker); // Add this line
                  if (!olMap) return;
                  const targetLayerSource = isHoverMarker ? jp2HoverMarkerLayer.getSource() : jp2TestMarkerLayer.getSource();
                  if (isHoverMarker) targetLayerSource.clear();

                  const ol_y = -jp2Y_img;
                  const feature = new ol.Feature({ geometry: new ol.geom.Point([jp2X_img, ol_y]) });
                  targetLayerSource.addFeature(feature);

                  if (isHoverMarker) {
                      jp2TargetCoordinatesDisplay.textContent = `JP2 Target: X=${jp2X_img.toFixed(0)}, Y=${jp2Y_img.toFixed(0)}`;
                  }
              }

              function hideHoverMarkerOnJP2() {
                  if (jp2HoverMarkerLayer && jp2HoverMarkerLayer.getSource()) {
                      jp2HoverMarkerLayer.getSource().clear();
                  }
                  jp2TargetCoordinatesDisplay.textContent = "JP2 Target: N/A";
              }
              function drawMarkerOnBFIOlMap(bfiX_img, bfiY_img, isHoverMarker = false) {
                  if (!bfiOlMap) return;
                  const targetLayerSource = isHoverMarker ? bfiHoverMarkerLayer.getSource() : bfiTestMarkerLayer.getSource();
                  if (isHoverMarker) targetLayerSource.clear();

                  // Convert from natural image coordinates (y-down) to BFI map projection coordinates (y-up)
                  const feature = new ol.Feature({ geometry: new ol.geom.Point([bfiX_img, bfiNaturalHeight - bfiY_img]) }); // OL uses y-up, so invert y
                  targetLayerSource.addFeature(feature);

                  if (isHoverMarker) {
                      // bfiTargetCoordinatesDisplay.textContent = `BFI Target: X=${bfiX_img.toFixed(0)}, Y=${bfiY_img.toFixed(0)}`;
                  }
              }

              function updateBFIViewRectangle() {
                  // Always hide the old DOM-based rectangle
                  bfiViewRect.style.display = 'none'; // Ensure the old DOM element is hidden

                  if (!olMap || !view || !bfiLoaded || !H_jp2_to_bfi || !bfiOlMap || !bfiViewRectLayer) {
                      if (bfiViewRectLayer) bfiViewRectLayer.getSource().clear();
                      return;
                  }

                  const jp2ExtentOL = view.calculateExtent(olMap.getSize());
                  const jp2_corners_img = [
                      [jp2ExtentOL[0], -jp2ExtentOL[3]], // tl
                      [jp2ExtentOL[2], -jp2ExtentOL[3]], // tr
                      [jp2ExtentOL[2], -jp2ExtentOL[1]], // br
                      [jp2ExtentOL[0], -jp2ExtentOL[1]], // bl
                  ];

                  const bfi_nat_corners = jp2_corners_img.map(p_jp2 => applyHomography(p_jp2, H_jp2_to_bfi)).filter(p => p !== null);

                  if (bfi_nat_corners.length < 4) {
                      bfiViewRectLayer.getSource().clear();
                      return;
                  }

                  const bfi_ol_coords = bfi_nat_corners.map(p => [p[0], bfiNaturalHeight - p[1]]);
                  const polygon = new ol.geom.Polygon([bfi_ol_coords]);
                  const feature = new ol.Feature(polygon);
                  // Clear previous rectangle and add the new one
                  bfiViewRectLayer.getSource().clear();
                  bfiViewRectLayer.getSource().addFeature(feature);
              }
              function sendCoordinatesToParent(jp2X, jp2Y, bfiX, bfiY, type = 'coordinate_update') {
                  //console.log('trying to send the coordinates:', jp2X, jp2Y, bfiX, bfiY, type);
                  window.parent.postMessage('testing', '*');
                  if (window.parent && window.parent !== window) {
                      try {
                          const message = {
                              type: type,
                              jp2_coordinates: jp2X !== null ? {
                                  x: jp2X,
                                  y: jp2Y
                              } : null,
                              bfi_coordinates: bfiX !== null ? {
                                  x: bfiX,
                                  y: bfiY
                              } : null,
                              timestamp: Date.now(),
                              biosample_id: currentBiosampleId,
                              slice_number: currentSliceNumber,
                              is_live: type === 'live_tracking'
                          };

                          window.parent.postMessage(message, '*');
                          //console.log('Sent coordinates to parent:', message);
                      } catch (error) {
                          console.error('Error sending message to parent:', error);
                      }
                  }
              }

              // RGB Opacity Controls - Define these before map initialization
              let jp2RGBOpacity = { r: 1, g: 1, b: 1 };
              let bfiRGBOpacity = { r: 1, g: 1, b: 1 };
              let jp2Gamma = 1.0;
              let bfiGamma = 1.0;
              let jp2RenderInterval, bfiRenderInterval;

              // Function to apply RGB filter to JP2 map
              function applyJP2RGBFilter() {
                  if (!olMap) return;
                  
                  // Force re-render with color matrix filter
                  olMap.once('postcompose', function(event) {
                      const canvas = event.context.canvas;
                      const ctx = event.context;
                      
                      // Apply color matrix filter
                      ctx.globalCompositeOperation = 'source-over';
                      
                      // Create ImageData from canvas
                      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                      const data = imageData.data;
                      
                      // Apply RGB channel opacity and gamma correction
                      for (let i = 0; i < data.length; i += 4) {
                          // Normalize to 0-1 range
                          let r = data[i] / 255;
                          let g = data[i + 1] / 255;
                          let b = data[i + 2] / 255;
                          
                          // Apply gamma correction
                          r = Math.pow(r, 1 / jp2Gamma);
                          g = Math.pow(g, 1 / jp2Gamma);
                          b = Math.pow(b, 1 / jp2Gamma);
                          
                          // Apply RGB channel opacity
                          r = r * jp2RGBOpacity.r;
                          g = g * jp2RGBOpacity.g;
                          b = b * jp2RGBOpacity.b;
                          
                          // Convert back to 0-255 range and clamp
                          data[i] = Math.min(255, Math.max(0, r * 255));
                          data[i + 1] = Math.min(255, Math.max(0, g * 255));
                          data[i + 2] = Math.min(255, Math.max(0, b * 255));
                          // Alpha channel (i + 3) remains unchanged
                      }
                      
                      // Put the modified image data back
                      ctx.putImageData(imageData, 0, 0);
                  });
                  
                  olMap.render();
              }

              // Function to apply RGB filter to BFI map
              function applyBFIRGBFilter() {
                  console.log('applyBFIRGBFilter called', {
                      bfiOlMap: !!bfiOlMap,
                      bfiRGBOpacity,
                      bfiGamma
                  });
                  
                  if (!bfiOlMap) {
                      console.log('No bfiOlMap found');
                      return;
                  }
                  
                  // Try direct method first (most reliable)
                  try {
                      applyBFIRGBFilterDirect();
                      return;
                  } catch (error) {
                      console.log('BFI direct method failed, trying postrender:', error);
                  }
                  
                  // Fallback to postrender event
                  bfiOlMap.once('postrender', function(event) {
                      try {
                          const canvas = bfiOlMap.getViewport().querySelector('canvas');
                          if (!canvas) {
                              applyBFIRGBFilterCSS();
                              return;
                          }
                          
                          const ctx = canvas.getContext('2d');
                          if (!ctx) {
                              applyBFIRGBFilterCSS();
                              return;
                          }
                          
                          // Create ImageData from canvas
                          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                          const data = imageData.data;
                          
                          // Apply RGB channel opacity and gamma correction
                          for (let i = 0; i < data.length; i += 4) {
                              // Skip transparent pixels
                              if (data[i + 3] === 0) continue;
                              
                              // Normalize to 0-1 range
                              let r = data[i] / 255;
                              let g = data[i + 1] / 255;
                              let b = data[i + 2] / 255;
                              
                              // Apply gamma correction
                              r = Math.pow(r, 1 / bfiGamma);
                              g = Math.pow(g, 1 / bfiGamma);
                              b = Math.pow(b, 1 / bfiGamma);
                              
                              // Apply RGB channel opacity
                              r = r * bfiRGBOpacity.r;
                              g = g * bfiRGBOpacity.g;
                              b = b * bfiRGBOpacity.b;
                              
                              // Convert back to 0-255 range and clamp
                              data[i] = Math.min(255, Math.max(0, r * 255));
                              data[i + 1] = Math.min(255, Math.max(0, g * 255));
                              data[i + 2] = Math.min(255, Math.max(0, b * 255));
                              // Alpha channel (i + 3) remains unchanged
                          }
                          
                          // Put the modified image data back
                          ctx.putImageData(imageData, 0, 0);
                      } catch (error) {
                          console.log('BFI postrender filter failed, using CSS method:', error);
                          applyBFIRGBFilterCSS();
                      }
                  });
                  
                  bfiOlMap.render();
              }
              
              // Alternative CSS-based filter for BFI
              function applyBFIRGBFilterCSS() {
                  const bfiMapElement = document.getElementById('bfi_ol_map');
                  if (!bfiMapElement) return;
                  
                  const canvas = bfiMapElement.querySelector('canvas');
                  if (!canvas) return;
                  
                  // Build CSS filter string
                  let filters = [];
                  
                  // Gamma correction using brightness
                  if (bfiGamma !== 1.0) {
                      const brightness = Math.pow(0.5, 1 / bfiGamma) * 2;
                      filters.push(`brightness(${brightness.toFixed(2)})`);
                  }
                  
                  // Overall opacity based on average RGB
                  const avgOpacity = (bfiRGBOpacity.r + bfiRGBOpacity.g + bfiRGBOpacity.b) / 3;
                  if (avgOpacity !== 1.0) {
                      filters.push(`opacity(${avgOpacity.toFixed(2)})`);
                  }
                  
                  // Apply saturation based on RGB variation
                  const rgbVariation = Math.abs(bfiRGBOpacity.r - bfiRGBOpacity.g) + 
                                     Math.abs(bfiRGBOpacity.g - bfiRGBOpacity.b) + 
                                     Math.abs(bfiRGBOpacity.b - bfiRGBOpacity.r);
                  if (rgbVariation > 0.1) {
                      const saturation = 1 - rgbVariation * 0.5;
                      filters.push(`saturate(${saturation.toFixed(2)})`);
                  }
                  
                  // Apply the combined filter
                  canvas.style.filter = filters.length > 0 ? filters.join(' ') : 'none';
                  
                  console.log('Applied BFI CSS filter:', canvas.style.filter);
              }
              
              // More direct method: Try to apply filter immediately after image loads
              function applyBFIRGBFilterDirect() {
                  const bfiMapElement = document.getElementById('bfi_ol_map');
                  if (!bfiMapElement || !bfiOlMap) return;
                  
                  // Wait for next frame to ensure rendering is complete
                  requestAnimationFrame(() => {
                      const canvas = bfiMapElement.querySelector('canvas');
                      if (!canvas) {
                          console.log('BFI canvas not found for direct filter');
                          return;
                      }
                      
                      try {
                          const ctx = canvas.getContext('2d');
                          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                          const data = imageData.data;
                          
                          let hasChanges = false;
                          
                          // Apply RGB and gamma filters
                          for (let i = 0; i < data.length; i += 4) {
                              if (data[i + 3] === 0) continue; // Skip transparent pixels
                              
                              // Normalize to 0-1
                              let r = data[i] / 255;
                              let g = data[i + 1] / 255;
                              let b = data[i + 2] / 255;
                              
                              // Apply gamma
                              if (bfiGamma !== 1.0) {
                                  r = Math.pow(r, 1 / bfiGamma);
                                  g = Math.pow(g, 1 / bfiGamma);
                                  b = Math.pow(b, 1 / bfiGamma);
                                  hasChanges = true;
                              }
                              
                              // Apply RGB opacity
                              if (bfiRGBOpacity.r !== 1 || bfiRGBOpacity.g !== 1 || bfiRGBOpacity.b !== 1) {
                                  r *= bfiRGBOpacity.r;
                                  g *= bfiRGBOpacity.g;
                                  b *= bfiRGBOpacity.b;
                                  hasChanges = true;
                              }
                              
                              // Convert back and clamp
                              data[i] = Math.min(255, Math.max(0, r * 255));
                              data[i + 1] = Math.min(255, Math.max(0, g * 255));
                              data[i + 2] = Math.min(255, Math.max(0, b * 255));
                          }
                          
                          if (hasChanges) {
                              ctx.putImageData(imageData, 0, 0);
                              console.log('Applied BFI direct filter successfully');
                          }
                      } catch (error) {
                          console.log('BFI direct filter failed, using CSS fallback:', error);
                          applyBFIRGBFilterCSS();
                      }
                  });
              }

              function startJP2RGBRendering() {
                  if (jp2RenderInterval) clearInterval(jp2RenderInterval);
                  jp2RenderInterval = setInterval(() => {
                      if (olMap && (jp2RGBOpacity.r !== 1 || jp2RGBOpacity.g !== 1 || jp2RGBOpacity.b !== 1 || jp2Gamma !== 1.0)) {
                          applyJP2RGBFilter();
                      }
                  }, 100);
              }

              function startBFIRGBRendering() {
                  if (bfiRenderInterval) clearInterval(bfiRenderInterval);
                  bfiRenderInterval = setInterval(() => {
                      if (bfiOlMap && (bfiRGBOpacity.r !== 1 || bfiRGBOpacity.g !== 1 || bfiRGBOpacity.b !== 1 || bfiGamma !== 1.0)) {
                          // Try multiple methods for BFI
                          try {
                              applyBFIRGBFilter();
                          } catch (error) {
                              console.log('Standard BFI filter failed, trying CSS method:', error);
                              applyBFIRGBFilterCSS();
                          }
                      } else if (bfiOlMap) {
                          // Reset filters when values are at default
                          const canvas = document.getElementById('bfi_ol_map')?.querySelector('canvas');
                          if (canvas) {
                              canvas.style.filter = 'none';
                          }
                      }
                  }, 100);
              }

              function initializeJP2Map() {
                  const zoomifySource = new ol.source.Zoomify({ url: jp2MapUrl, size: jp2FullSize, crossOrigin: "anonymous", tierSizeCalculation: 'truncated', imageSmoothing: false, tileSize: 2048 });
                  const tileLayer = new ol.layer.Tile({ source: zoomifySource });
                  const imageExtent = zoomifySource.getTileGrid().getExtent();
                  const pixelProjection = new ol.proj.Projection({ code: 'pixel-coords', units: 'pixels', extent: imageExtent });

                  const sourceMaxZoom = zoomifySource.getTileGrid().getMaxZoom();
                  const desiredViewMaxZoom = Math.min(sourceMaxZoom + 3, 10);;

                  view = new ol.View({
                      projection: pixelProjection,
                      extent: imageExtent,
                      rotation: (jp2InitialViewRotationDeg * Math.PI / 180),
                      constrainOnlyCenter: true,
                      smoothExtentConstraint: false,
                      maxZoom: desiredViewMaxZoom,
                      minZoom: 0
                  });

                  jp2TestMarkerLayer = new ol.layer.Vector({
                      source: new ol.source.Vector(),
                      style: new ol.style.Style({
                          image: new ol.style.Circle({
                              radius: 7,
                              fill: new ol.style.Fill({color: 'limegreen'}),
                              stroke: new ol.style.Stroke({color: 'darkgreen', width: 2})
                          })
                      }),
                      zIndex: 10
                  });
                  jp2HoverMarkerLayer = new ol.layer.Vector({
                      source: new ol.source.Vector(),
                      style: new ol.style.Style({
                          image: new ol.style.Circle({
                              radius: 5,
                              fill: new ol.style.Fill({color: 'rgba(255, 0, 0, 0.8)'}),
                              stroke: new ol.style.Stroke({color: 'black', width: 1})
                          })
                      }),
                      zIndex: 11
                  });

                  olMap = new ol.Map({
                      layers: [tileLayer, jp2TestMarkerLayer, jp2HoverMarkerLayer],
                      target: mapElement,
                      view: view,
                      controls: ol.control.defaults({ attribution: false, rotate: false, zoom: false })
                               .extend([new ol.control.ZoomSlider()]),
                      loadTilesWhileAnimating: true,
                      loadTilesWhileInteracting: true
                  });

                  try {
                      if (view.getProjection() && view.getProjection().getExtent()) {
                          view.fit(view.getProjection().getExtent(), { size: olMap.getSize(), constrainResolution: false, nearest: true });
                      }
                  }
                  catch (e) { console.error("Error fitting JP2 view:", e); }

                  // In your JP2 map pointermove event handler, replace the existing handler with this:
                  olMap.on('pointermove', function(event) {
                      if (event.dragging || !bfiLoaded || !H_jp2_to_bfi || isDraggingBFIRect) {
                          sendCoordinatesToParent(null, null, null, null, 'live_tracking');
                          return;
                      }
                      try {
                          const ol_jp2Coord = olMap.getEventCoordinate(event.originalEvent);
                          if (ol_jp2Coord) {
                              const jp2X_for_H = ol_jp2Coord[0];
                              const jp2Y_for_H = -ol_jp2Coord[1];

                              coordinatesDisplay.textContent = `JP2 Mouse: X=${Math.round(jp2X_for_H)}, Y=${Math.round(jp2Y_for_H)} (Z: ${view.getZoom().toFixed(2)})`;
                              drawMarkerOnJP2(jp2X_for_H, jp2Y_for_H, true);

                              // Declare bfiCoord_nat only once
                              const bfiCoord_nat = applyHomography([jp2X_for_H, jp2Y_for_H], H_jp2_to_bfi);
                              if (bfiCoord_nat && bfiOlMap && bfiHoverMarkerLayer) {
                                  drawMarkerOnBFIOlMap(bfiCoord_nat[0], bfiCoord_nat[1], true);
                              }

                              const currentSize = getCurrentJP2Size();
                              if (jp2X_for_H < 0 || jp2X_for_H > currentSize[0] || jp2Y_for_H < 0 || jp2Y_for_H > currentSize[1]) {
                                  sendCoordinatesToParent(null, null, null, null, 'live_tracking');
                                  return;
                              }

                              // Use the same bfiCoord_nat variable here
                              if (bfiCoord_nat) {
                                  if (bfiOlMap && bfiHoverMarkerLayer) {
                                      drawMarkerOnBFIOlMap(bfiCoord_nat[0], bfiCoord_nat[1], true);
                                  }
                                  sendCoordinatesToParent(
                                      Math.round(jp2X_for_H),
                                      Math.round(jp2Y_for_H),
                                      Math.round(bfiCoord_nat[0]),
                                      Math.round(bfiCoord_nat[1]),
                                      'live_tracking'
                                  );
                              } else {
                                  sendCoordinatesToParent(
                                      Math.round(jp2X_for_H),
                                      Math.round(jp2Y_for_H),
                                      null,
                                      null,
                                      'live_tracking'
                                  );
                              }
                          } else {
                              sendCoordinatesToParent(null, null, null, null, 'live_tracking');
                          }
                      } catch (e) {
                          console.error("Error in JP2 pointermove:", e);
                          if (bfiHoverMarkerLayer && bfiHoverMarkerLayer.getSource()) { bfiHoverMarkerLayer.getSource().clear(); }
                          sendCoordinatesToParent(null, null, null, null, 'live_tracking');
                      }
                  });

                mapElement.addEventListener('mouseleave', function() {
                      if (isDraggingBFIRect) return;
                      coordinatesDisplay.textContent = "JP2 Mouse: N/A";
                      // hideCrosshairOnBFI(bfiHoverCrosshairLines); // No longer needed
                      if (bfiHoverMarkerLayer && bfiHoverMarkerLayer.getSource()) { bfiHoverMarkerLayer.getSource().clear(); }

                      // Send null coordinates when mouse leaves JP2 map
                      sendCoordinatesToParent(null, null, null, null, 'live_tracking');
                  });
                  //olMap.on('moveend', updateBFIViewRectangle);
                  olMap.on('moveend', function() {
                      updateBFIViewRectangle();
                      if (syncEnabled && !isUpdatingFromSync && bfiOlMap && bfiView && (isSplitView || jp2IsFullscreen)) {
                          syncBFIToBJP2();
                      }
                  });
                  
                  // Start RGB rendering for JP2 if needed
                  startJP2RGBRendering();
              }

              function loadBFIThumbnail() {
                   if (!bfiImageUrl) {
                      console.error("BFI Image URL is not available.");
                      handleBfiLoadError();
                      return;
                  } // The img tag is now primarily for loading natural dimensions.
                  bfiThumbnailImg.src = bfiImageUrl;
                  // bfiThumbnailImg.style.transform = `rotate(${bfiCssRotationDeg}deg)`; // OL map handles rotation
                  // bfiThumbnailImg.style.transformOrigin = 'center center'; // OL map handles origin
                  bfiLoaded = false;
                  bfiThumbnailImg.onload = () => {
                      bfiNaturalWidth = bfiThumbnailImg.naturalWidth;
                      bfiNaturalHeight = bfiThumbnailImg.naturalHeight;

                      //console.log("BFI image loaded. Actual natural dimensions: W=", bfiNaturalWidth, "H=", bfiNaturalHeight);

                      if (bfiNaturalWidth === 0 || bfiNaturalHeight === 0) {
                          console.warn("BFI image loaded but natural dimensions from element are zero. Using placeholder logic.");
                          handleBfiLoadError();
                          return;
                      }
                      bfiLoaded = true;

                      // Initialize the BFI OpenLayers map once dimensions are known.
                      // This map will be used for both thumbnail and fullscreen views.
                      initializeBFIMap();

                      placeTestMarkers();
                      updateBFIViewRectangle();
                  };
                  bfiThumbnailImg.onerror = handleBfiLoadError;
              }

              function handleBfiLoadError() {
                   console.error("Failed to load BFI image or invalid dimensions (path: " + bfiImageUrl + "). Using placeholder.");
                  if(bfiViewRect) bfiViewRect.style.display = 'none'; // Old DOM element
                  if (bfiThumbOverlay) bfiThumbOverlay.querySelectorAll('.test-marker-bfi').forEach(m => m.remove()); // Old DOM markers

                  bfiThumbnailImg.src = "https://via.placeholder.com/300x250.png?text=BFI+Error";
                  bfiThumbnailImg.onload = () => {
                      bfiNaturalWidth = 300; // Placeholder dimensions
                      bfiNaturalHeight = 250;
                      //console.log("BFI placeholder loaded. Natural Dims set to: W=", bfiNaturalWidth, "H=", bfiNaturalHeight);
                      bfiLoaded = true;
                      placeTestMarkers();
                      updateBFIViewRectangle();
                  };
                  bfiThumbnailImg.onerror = () => {
                      console.error("CRITICAL: Failed to load even the placeholder BFI image. BFI functionality will be broken.");
                      bfiLoaded = false;
                  }
              }

              function placeTestMarkers() {
                  if (!bfiLoaded || !olMap || !H_jp2_to_bfi || !jp2TestMarkerLayer) {
                      return;
                  }
                  const jp2MarkerSource = jp2TestMarkerLayer.getSource(); // Clear JP2 test markers
                  jp2MarkerSource.clear();
                  bfiThumbOverlay.querySelectorAll('.test-marker-bfi').forEach(m => m.remove());
                  if (bfiTestMarkerLayer && bfiTestMarkerLayer.getSource()) {
                      bfiTestMarkerLayer.getSource().clear();
                  }
                  if (!testPointsJP2 || testPointsJP2.length === 0) {
                      return;
                  }

                  testPointsJP2.forEach(jp2Point => {
                      drawMarkerOnJP2(jp2Point.x, jp2Point.y, false);
                      const bfiCoord = applyHomography([jp2Point.x, jp2Point.y], H_jp2_to_bfi); // Transform to BFI natural coords
                      if (bfiCoord && bfiOlMap && bfiTestMarkerLayer) { // Only draw if BFI OL map is initialized
                          drawMarkerOnBFIOlMap(bfiCoord[0], bfiCoord[1], false); // Draw on BFI OL map
                      }
                  });
              }

              function getJP2CoordsFromBFInat(bfiX_nat, bfiY_nat) {
                  if (!H_bfi_to_jp2 || bfiX_nat == null || bfiY_nat == null) return null;
                  return applyHomography([bfiX_nat, bfiY_nat], H_bfi_to_jp2);
              }

              function setJP2ViewCenterFromImageCoords(jp2_coords_img) {
                  if (jp2_coords_img && olMap && view) {
                      const targetOlX = jp2_coords_img[0];
                      const targetOlY = -jp2_coords_img[1];
                      view.setCenter([targetOlX, targetOlY]);
                  }
              }

              let currentJP2ImageType = 'original'; // 'original', 'nissl'
              let currentBFIImageType = 'original'; // 'original', 'mri'
              
              // Function to get current JP2 image size based on type
              function getCurrentJP2Size() {
                  return currentJP2ImageType === 'nissl' ? nisslFullSize : jp2FullSize;
              }

                // Function to update JP2 image source
            function updateJP2Image(imageType) {
                if (!olMap || !view) return;

                let newUrl, newSize, newRotation;
                if (imageType === 'nissl') {
                newUrl = nisslImageUrl + '?t=' + Date.now();
                newSize = nisslFullSize;
                newRotation = nisslInitialViewRotationDeg * Math.PI / 180;
                currentJP2ImageType = 'nissl';
                } else {
                newUrl = jp2MapUrl + '?t=' + Date.now();
                newSize = jp2FullSize;
                newRotation = jp2InitialViewRotationDeg * Math.PI / 180;
                currentJP2ImageType = 'original';
                }

                // Get current view state
                const currentCenter = view.getCenter();
                const currentZoom = view.getZoom();
                const currentRotation = view.getRotation();
                const currentResolution = view.getResolution();

                // Create new source with the new URL
                const newZoomifySource = new ol.source.Zoomify({
                url: newUrl,
                size: newSize,
                crossOrigin: "anonymous",
                tierSizeCalculation: 'truncated',
                imageSmoothing: false,
                tileSize: 2048
                });

                // Update the tile layer source
                const tileLayer = olMap.getLayers().getArray()[0]; // Assuming first layer is the tile layer
                tileLayer.setSource(newZoomifySource);

                // Update view extent if size changed
                const imageExtent = newZoomifySource.getTileGrid().getExtent();
                view.getProjection().setExtent(imageExtent);

                // Restore view state
                setTimeout(() => {
                            const referenceSize = currentJP2ImageType === 'original' ? jp2FullSize : nisslFullSize;
                            if (newSize[0] !== referenceSize[0] || newSize[1] !== referenceSize[1]) {
                                // Scale center position based on size ratio
                                const xRatio = newSize[0] / referenceSize[0];
                                const yRatio = newSize[1] / referenceSize[1];
                                const scaledCenter = [
                                    currentCenter[0] * xRatio,
                                    currentCenter[1] * yRatio
                                ];
                                view.setCenter(scaledCenter);
                                
                                // Adjust resolution based on size ratio
                                const avgRatio = (xRatio + yRatio) / 2;
                                view.setResolution(currentResolution / avgRatio);
                            } else {
                                view.setCenter(currentCenter);
                                view.setResolution(currentResolution);
                            }
                            view.setRotation(newRotation);
                        }, 100);
                    }

                // Function to update BFI image source
        function updateBFIImage(imageType) {
                if (!bfiOlMap || !bfiView) return;

                let newUrl, newSize, newRotation;
                if (imageType === 'mri') {
                newUrl = mriImageUrl + '?t=' + Date.now();
                newSize = mriFullSize;
                newRotation = mriInitialViewRotationDeg * Math.PI / 180;
                currentBFIImageType = 'mri';
                } else {
                newUrl = bfiImageUrl + '?t=' + Date.now();
                newSize = [bfiNaturalWidth, bfiNaturalHeight];
                newRotation = bfiCssRotationDeg * Math.PI / 180;
                currentBFIImageType = 'original';
                }

                // Get current view state
                const currentCenter = bfiView.getCenter();
                const currentZoom = bfiView.getZoom();
                const currentRotation = bfiView.getRotation();
                const currentResolution = bfiView.getResolution();

                const extent = [0, 0, newSize[0], newSize[1]];
                // Update the image layer source
                const imageLayer = bfiOlMap.getLayers().getArray()[0]; // Assuming first layer is the image layer
                const newImageSource = new ol.source.ImageStatic({
                url: newUrl,
                imageExtent: extent,
                projection: bfiView.getProjection()
                });
                imageLayer.setSource(newImageSource);

                // Update view projection extent
                bfiView.getProjection().setExtent(extent);

                // Restore view state
                 setTimeout(() => {
                    if (newSize[0] !== bfiNaturalWidth || newSize[1] !== bfiNaturalHeight) {
                        // Scale center position based on size ratio
                        const xRatio = newSize[0] / bfiNaturalWidth;
                        const yRatio = newSize[1] / bfiNaturalHeight;
                        const scaledCenter = [
                            currentCenter[0] * xRatio,
                            currentCenter[1] * yRatio
                        ];
                        bfiView.setCenter(scaledCenter);
                        
                        // Adjust resolution based on size ratio
                        const avgRatio = (xRatio + yRatio) / 2;
                        bfiView.setResolution(currentResolution / avgRatio);
                    } else {
                        bfiView.setCenter(currentCenter);
                        bfiView.setResolution(currentResolution);
                    }
                    bfiView.setRotation(currentRotation);
                    
                    // Update BFI natural dimensions for coordinate transformations
                    if (imageType === 'mri') {
                        bfiNaturalWidth = mriFullSize[0];
                        bfiNaturalHeight = mriFullSize[1];
                    }
                }, 100);
            }


            let syncEnabled = true; // Add this variable to control sync behavior
            let isUpdatingFromSync = false;
            function syncBFIToBJP2() {
                  if (!bfiOlMap || !bfiView || !olMap || !view || !H_jp2_to_bfi) return;

                  isUpdatingFromSync = true;

                  try {
                      // Get JP2 center and convert to BFI coordinates
                      const jp2Center = view.getCenter();
                      const jp2CenterImg = [jp2Center[0], -jp2Center[1]];
                      const bfiCenterNat = applyHomography(jp2CenterImg, H_jp2_to_bfi);

                      if (bfiCenterNat) {
                          const bfiCenterOL = [bfiCenterNat[0], bfiNaturalHeight - bfiCenterNat[1]];

                          // Constrain BFI center to image bounds
                          const constrainedBfiCenter = [
                              Math.max(0, Math.min(bfiNaturalWidth, bfiCenterOL[0])),
                              Math.max(0, Math.min(bfiNaturalHeight, bfiCenterOL[1]))
                          ];

                          bfiView.setCenter(constrainedBfiCenter);
                      }

                      // Sync zoom
                      const jp2Resolution = view.getResolution();
                      const currentSize = getCurrentJP2Size();
                      const jp2ImageSize = Math.max(currentSize[0], currentSize[1]);
                      const bfiImageSize = Math.max(bfiNaturalWidth, bfiNaturalHeight);
                      const sizeRatio = bfiImageSize / jp2ImageSize;
                      const equivalentBfiResolution = jp2Resolution * sizeRatio;
                      //console.log("Equivalent BFI resolution:", equivalentBfiResolution);

                      // Constrain resolution to valid range
                      const constrainedResolution = Math.max(
                          bfiView.getMinResolution(),
                          Math.min(bfiView.getMaxResolution(), equivalentBfiResolution)
                      );
                      //console.log("Constrained BFI resolution:", constrainedResolution);

                      bfiView.setResolution(constrainedResolution);

                  } catch (e) {
                      console.error("Error syncing BFI to JP2:", e);
                  }

                  setTimeout(() => {
                      isUpdatingFromSync = false;
                  }, 100);
              }

              function syncJP2ToBFI() {
                  if (!bfiOlMap || !bfiView || !olMap || !view || !H_bfi_to_jp2) return;

                  isUpdatingFromSync = true;

                  try {
                      // Get BFI center and convert to JP2 coordinates
                      const bfiCenter = bfiView.getCenter();
                      const bfiCenterNat = [bfiCenter[0], bfiNaturalHeight - bfiCenter[1]];
                      const jp2CenterImg = applyHomography(bfiCenterNat, H_bfi_to_jp2);

                      if (jp2CenterImg) {
                          const jp2CenterOL = [jp2CenterImg[0], -jp2CenterImg[1]];

                          // Constrain JP2 center to image bounds
                          const currentSize = getCurrentJP2Size();
                          const constrainedJP2Center = [
                              Math.max(0, Math.min(currentSize[0], jp2CenterOL[0])),
                              Math.max(-currentSize[1], Math.min(0, jp2CenterOL[1]))
                          ];

                          view.setCenter(constrainedJP2Center);
                      }

                      // Sync zoom
                      const bfiResolution = bfiView.getResolution();
                      const currentSize = getCurrentJP2Size();
                      const jp2ImageSize = Math.max(currentSize[0], currentSize[1]);
                      const bfiImageSize = Math.max(bfiNaturalWidth, bfiNaturalHeight);
                      const sizeRatio = jp2ImageSize / bfiImageSize;
                      const equivalentJP2Resolution = bfiResolution * sizeRatio;

                      // Constrain resolution to valid range
                      const constrainedResolution = Math.max(
                          view.getMinResolution(),
                          Math.min(view.getMaxResolution(), equivalentJP2Resolution)
                      );

                      view.setResolution(constrainedResolution);

                  } catch (e) {
                      console.error("Error syncing JP2 to BFI:", e);
                  }

                  setTimeout(() => {
                      isUpdatingFromSync = false;
                  }, 100);
              }

              function constrainViewToImageBounds(mapView, imageWidth, imageHeight, isJP2 = false) {
                  const currentCenter = mapView.getCenter();
                  const currentResolution = mapView.getResolution();
                  const mapSize = mapView.getViewport ? mapView.getViewport().getSize() : [512, 512];

                  // Calculate view extent
                  const halfWidth = (mapSize[0] * currentResolution) / 2;
                  const halfHeight = (mapSize[1] * currentResolution) / 2;

                  let constrainedX, constrainedY;

                  if (isJP2) {
                      // For JP2 (y-axis is inverted)
                      constrainedX = Math.max(halfWidth, Math.min(imageWidth - halfWidth, currentCenter[0]));
                      constrainedY = Math.max(-imageHeight + halfHeight, Math.min(-halfHeight, currentCenter[1]));
                  } else {
                      // For BFI (normal y-axis)
                      constrainedX = Math.max(halfWidth, Math.min(imageWidth - halfWidth, currentCenter[0]));
                      constrainedY = Math.max(halfHeight, Math.min(imageHeight - halfHeight, currentCenter[1]));
                  }

                  if (constrainedX !== currentCenter[0] || constrainedY !== currentCenter[1]) {
                      mapView.setCenter([constrainedX, constrainedY]);
                  }
              }


              let isSplitView = false;

              function toggleSplitView() {
                isSplitView = !isSplitView;
                const splitModeOverlay = document.getElementById('splitModeOverlay');
                const splitViewBtn = document.getElementById('splitViewBtn');
                const switchViewBtn = document.getElementById('switchViewBtn');

                if (isSplitView) {
                    // Split view mode
                    splitViewBtn.textContent = 'Exit Split View';
                    splitViewBtn.style.display = 'inline-block';
                    switchViewBtn.textContent = 'View BFI Fullscreen';
                    switchViewBtn.style.display = 'inline-block';

                    splitModeOverlay.classList.add('active');
                    mapElement.classList.add('split-left');
                    mapElement.classList.remove('thumbnail-mode');
                    mapElement.style.display = 'block';

                    bfiThumbnailContainer.classList.add('split-right');
                    bfiThumbnailContainer.classList.add('fullscreen-mode');

                    mapElement.style.position = 'absolute';
                    mapElement.style.top = '0';
                    mapElement.style.left = '0';
                    mapElement.style.width = '50%';
                    mapElement.style.height = '100%';

                    bfiThumbnailContainer.style.position = 'absolute';
                    bfiThumbnailContainer.style.top = '0';
                    bfiThumbnailContainer.style.left = '50%';
                    bfiThumbnailContainer.style.width = '50%';
                    bfiThumbnailContainer.style.height = '100%';

                    initializeBFIMap();

                    // Apply zoom adjustment for split mode images
                    setTimeout(() => {
                        // Fit and zoom JP2 image for split view
                        if (olMap && view && view.getProjection() && view.getProjection().getExtent()) {
                            try {
                                olMap.updateSize();
                                view.fit(view.getProjection().getExtent(), {
                                    size: olMap.getSize(),
                                    constrainResolution: false,
                                    nearest: true,
                                    duration: 0
                                });
                                const currentJP2Resolution = view.getResolution();
                                view.setResolution(currentJP2Resolution / 0.9);
                            } catch (e) { console.error("Error applying JP2 zoom in split mode:", e); }
                        }
                        
                        // Fit and zoom BFI image for split view
                        if (bfiOlMap && bfiView && bfiView.getProjection() && bfiView.getProjection().getExtent()) {
                            try {
                                bfiView.fit(bfiView.getProjection().getExtent(), {
                                    size: bfiOlMap.getSize(),
                                    constrainResolution: false,
                                    nearest: true,
                                    duration: 0
                                });
                                const currentBfiResolution = bfiView.getResolution();
                                bfiView.setResolution(currentBfiResolution / 1.9);
                            } catch (e) { console.error("Error applying BFI zoom in split mode:", e); }
                        }
                    }, 100);

                    requestAnimationFrame(() => {
                        if (olMap) {
                            olMap.updateSize();
                            if (view && view.getProjection() && view.getProjection().getExtent()) {
                                try {
                                    view.fit(view.getProjection().getExtent(), {
                                        size: olMap.getSize(),
                                        constrainResolution: false,
                                        nearest: true,
                                        duration: 0
                                    });
                                    // Apply zoom adjustment for split mode JP2 image to fit viewport properly
                                    const currentResolution = view.getResolution();
                                    view.setResolution(currentResolution / 0.9);

                                    if (bfiOlMap && bfiView && bfiView.getProjection() && bfiView.getProjection().getExtent()) {
                                        try {
                                            bfiOlMap.updateSize();
                                            bfiView.fit(bfiView.getProjection().getExtent(), {
                                                size: bfiOlMap.getSize(),
                                                constrainResolution: false,
                                                nearest: true,
                                                duration: 0
                                            });
                                            const currentBfiResolution = bfiView.getResolution();
                                            bfiView.setResolution(currentBfiResolution / 1.9);
                                        } catch (e) { console.error("Error fitting or zooming BFI view in split mode:", e); }
                                    }
                                } catch (e) { console.error("Error fitting or zooming JP2 view in split mode:", e); }
                            }
                        }
                    });

                } else {
                    // Back to JP2 fullscreen
                    splitViewBtn.textContent = 'Split View';
                    switchViewBtn.textContent = 'View BFI Fullscreen';
                    switchViewBtn.style.display = 'inline-block';

                    splitModeOverlay.classList.remove('active');

                    if (currentJP2ImageType !== 'original') {
                        updateJP2Image('original');
                    }
                    if (currentBFIImageType !== 'original') {
                        updateBFIImage('original');
                    }

                    mapElement.style.cssText = '';
                    bfiThumbnailContainer.style.cssText = '';

                    mapElement.classList.remove('split-left');
                    bfiThumbnailContainer.classList.remove('split-right');

                    mapElement.classList.remove('thumbnail-mode');
                    bfiThumbnailContainer.classList.remove('fullscreen-mode');

                    mapElement.classList.add('jp2-fullscreen');
                    bfiThumbnailContainer.classList.remove('fullscreen-mode');

                    document.getElementById('bfi_ol_map').style.display = 'block';
                    document.getElementById('bfi_thumbnail_img').style.display = 'none';
                    bfiThumbOverlay.style.pointerEvents = 'none';

                    if (bfiOlMap) bfiOlMap.updateSize();
                    if (olMap) olMap.updateSize();
                }

                if (olMap) olMap.updateSize();
              }


          function initializeBFIMap() {
              // Ensure natural dimensions are available before initializing the map
              if (!bfiLoaded || bfiNaturalWidth === 0 || bfiNaturalHeight === 0) {
                  console.warn("BFI image not loaded or dimensions not available yet. Cannot initialize BFI OpenLayers map.");
                  return;
              } // This check is crucial

              if (bfiOlMap) {
                  // console.log('bfiOlMap already initialized, updating size');
                  bfiOlMap.updateSize();
                  // Re-add test markers if they were cleared or not present
                  placeTestMarkers(); // Call the unified placeTestMarkers
                  
                  // Apply zoom adjustment for split mode
                  if (isSplitView && bfiView && bfiView.getProjection() && bfiView.getProjection().getExtent()) {
                      try {
                          bfiView.fit(bfiView.getProjection().getExtent(), {
                              size: bfiOlMap.getSize(),
                              constrainResolution: false,
                              nearest: true,
                              duration: 0
                          });
                          const currentBfiResolution = bfiView.getResolution();
                          bfiView.setResolution(currentBfiResolution / 1.9);
                      } catch (e) { console.error("Error applying BFI zoom in split mode:", e); }
                  }
                  return;
              }

              const imageUrl = bfiImageUrl;
              const imgWidth = bfiNaturalWidth; // Use actual natural width
              const imgHeight = bfiNaturalHeight; // Use actual natural height
              const extent = [0, 0, imgWidth, imgHeight];

              // Define a pixel projection for the BFI image
              const pixelProjectionBFI = new ol.proj.Projection({
                  code: 'pixel-coords-bfi', // Unique code for BFI pixel projection
                  units: 'pixels',
                  extent: extent // The extent of the image in its own pixel coordinate system
              });

              const imageLayer = new ol.layer.Image({
                  source: new ol.source.ImageStatic({
                      url: imageUrl,
                      imageExtent: extent,
                      projection: pixelProjectionBFI // Use the defined pixel projection
                  })
              });

              // Create marker layers for BFI, similar to JP2
              bfiTestMarkerLayer = new ol.layer.Vector({
                  source: new ol.source.Vector(),
                  style: new ol.style.Style({
                      image: new ol.style.Circle({
                          radius: 7,
                          fill: new ol.style.Fill({color: 'orange'}), // Different color for BFI markers
                          stroke: new ol.style.Stroke({color: 'darkorange', width: 2})
                      })
                  }),
                  zIndex: 10
              });
              bfiHoverMarkerLayer = new ol.layer.Vector({
                  source: new ol.source.Vector(),
                  style: new ol.style.Style({
                      image: new ol.style.Circle({
                          radius: 5,
                          fill: new ol.style.Fill({color: 'rgba(0, 0, 255, 0.8)'}), // Blue for BFI hover
                          stroke: new ol.style.Stroke({color: 'darkblue', width: 1})
                      })
                  }),
                  zIndex: 11
              });

              // Layer for the JP2 view rectangle
              bfiViewRectLayer = new ol.layer.Vector({
                  source: new ol.source.Vector(),
                  style: new ol.style.Style({
                      stroke: new ol.style.Stroke({
                          color: 'rgba(255, 0, 0, 0.8)',
                          width: 2
                      }),
                      fill: new ol.style.Fill({
                          color: 'rgba(255, 0, 0, 0)'
                      })
                  }),
                  zIndex: 100 // Ensure the view rectangle is on top for dragging
              });

              bfiView = new ol.View({
                  projection: pixelProjectionBFI, // Use the BFI pixel projection
                  extent: extent,
                  constrainOnlyCenter: true,
                  smoothExtentConstraint: false,
                  center: [imgWidth / 2, imgHeight / 2],
                  zoom: 0, // Start at a low zoom to see the whole image
                  maxZoom: 10, // Adjust as needed
                  minZoom: 0, // Allow zooming out to see the whole image
                  rotation: (bfiCssRotationDeg * Math.PI / 180) // Apply the BFI image's rotation
              });

              bfiOlMap = new ol.Map({
                  layers: [imageLayer, bfiViewRectLayer, bfiTestMarkerLayer, bfiHoverMarkerLayer], // Add layers
                  target: 'bfi_ol_map', // Target element for the BFI OpenLayers map
                  view: bfiView,
                  controls: ol.control.defaults({ attribution: false, rotate: false, zoom: false })
                                  .extend([new ol.control.ZoomSlider()]),
                  loadTilesWhileAnimating: true,
                  loadTilesWhileInteracting: true
              });

              try {
                  if (bfiView.getProjection() && bfiView.getProjection().getExtent()) {
                      bfiView.fit(bfiView.getProjection().getExtent(), { size: bfiOlMap.getSize(), constrainResolution: false, nearest: true });
                      const currentResolution = bfiView.getResolution();
                      bfiView.setResolution(currentResolution / 3);
                  } // Fit the BFI map to its container
              }
              catch (e) { console.error("Error fitting BFI view:", e); }

              // Interaction to drag the view rectangle and pan the JP2 map
              const translate = new ol.interaction.Translate({
                  layers: [bfiViewRectLayer]
              });
              translate.on('translateend', function(evt) {
                  const newPolygon = evt.features.getArray()[0].getGeometry();
                  const newCenterBfiOl = ol.extent.getCenter(newPolygon.getExtent()); // Center of the dragged rectangle in OL coords

                  // Convert back to natural image coordinates (y-down)
                  const newCenterBfiNat = [newCenterBfiOl[0], bfiNaturalHeight - newCenterBfiOl[1]];

                  const newCenterJp2 = getJP2CoordsFromBFInat(newCenterBfiNat[0], newCenterBfiNat[1]);
                  if (newCenterJp2) {
                      setJP2ViewCenterFromImageCoords(newCenterJp2);
                  }
              });
              bfiOlMap.addInteraction(translate);

              // Enable default drag pan for the BFI map itself
              bfiOlMap.addInteraction(new ol.interaction.DragPan());

              // Disable map zoom on scroll, we'll handle it manually to zoom JP2
              bfiOlMap.getInteractions().forEach(function(interaction) {
                  if (interaction instanceof ol.interaction.MouseWheelZoom) {
                      interaction.setActive(false);
                  }
              });

              // Add event listeners for BFI map interactions
              bfiOlMap.on('pointermove', function(event) {
                  if (event.dragging || !H_bfi_to_jp2) {
                      if (bfiHoverMarkerLayer && bfiHoverMarkerLayer.getSource()) {
                          bfiHoverMarkerLayer.getSource().clear();
                      }
                      sendCoordinatesToParent(null, null, null, null, 'live_tracking');
                      return;
                  }
                  try {
                      const ol_bfiCoord = bfiOlMap.getEventCoordinate(event.originalEvent);
                      if (ol_bfiCoord) {
                          const bfiX_for_H = ol_bfiCoord[0];
                          const bfiY_for_H = bfiNaturalHeight - ol_bfiCoord[1]; // Convert from OL y-up to natural y-down for homography

                          coordinatesDisplay.textContent = `BFI Mouse: X=${Math.round(bfiX_for_H)}, Y=${Math.round(bfiY_for_H)} (Z: ${bfiView.getZoom().toFixed(2)})`;

                          drawMarkerOnBFIOlMap(bfiX_for_H, bfiY_for_H, true); // Draw hover marker on BFI map

                          // Declare jp2Coord_img only once
                          const jp2Coord_img = applyHomography([bfiX_for_H, bfiY_for_H], H_bfi_to_jp2);
                          if (jp2Coord_img && olMap && jp2HoverMarkerLayer) {
                              drawMarkerOnJP2(jp2Coord_img[0], jp2Coord_img[1], true);
                          }

                          if (bfiX_for_H < 0 || bfiX_for_H > imgWidth || bfiY_for_H < 0 || bfiY_for_H > imgHeight) {
                              if (bfiHoverMarkerLayer && bfiHoverMarkerLayer.getSource()) {
                                  bfiHoverMarkerLayer.getSource().clear();
                              }
                              sendCoordinatesToParent(null, null, null, null, 'live_tracking');
                              return;
                          }

                          // Use the same jp2Coord_img variable here
                          if (jp2Coord_img) {
                              drawMarkerOnJP2(jp2Coord_img[0], jp2Coord_img[1], true); // Draw hover marker on JP2 map
                              sendCoordinatesToParent(
                                  Math.round(jp2Coord_img[0]),
                                  Math.round(jp2Coord_img[1]),
                                  Math.round(bfiX_for_H),
                                  Math.round(bfiY_for_H),
                                  'live_tracking'
                              );
                          } else {
                              sendCoordinatesToParent(
                                  null,
                                  null,
                                  Math.round(bfiX_for_H),
                                  Math.round(bfiY_for_H),
                                  'live_tracking'
                              );
                          }
                      } else {
                          if (bfiHoverMarkerLayer && bfiHoverMarkerLayer.getSource()) {
                              bfiHoverMarkerLayer.getSource().clear();
                          }
                          sendCoordinatesToParent(null, null, null, null, 'live_tracking');
                      }
                  } catch (e) {
                      console.error("Error in BFI pointermove:", e);
                      if (bfiHoverMarkerLayer && bfiHoverMarkerLayer.getSource()) {
                          bfiHoverMarkerLayer.getSource().clear();
                      }
                      sendCoordinatesToParent(null, null, null, null, 'live_tracking');
                  }
              });

              // Event listener for mouse leaving the BFI map area
              document.getElementById('bfi_ol_map').addEventListener('mouseleave', function() {
                  //hideHoverMarkerOnJP2();
                  if (bfiHoverMarkerLayer && bfiHoverMarkerLayer.getSource()) { // Clear BFI hover marker
                      bfiHoverMarkerLayer.getSource().clear();
                  }
                  coordinatesDisplay.textContent = "BFI Mouse: N/A"; // Clear BFI mouse display
                  sendCoordinatesToParent(null, null, null, null, 'live_tracking');
              });

              // Add click handler for BFI map to set JP2 view center
              bfiOlMap.on('click', function(event) {
                  if (!H_bfi_to_jp2) return;
                  try {
                      const ol_bfiCoord = bfiOlMap.getEventCoordinate(event.originalEvent);
                      if (ol_bfiCoord) {
                          const bfiX_for_H = ol_bfiCoord[0];
                          const bfiY_for_H = bfiNaturalHeight - ol_bfiCoord[1]; // Convert from OL y-up to natural y-down

                          const jp2Coord_img = applyHomography([bfiX_for_H, bfiY_for_H], H_bfi_to_jp2);
                          if (jp2Coord_img) {
                              setJP2ViewCenterFromImageCoords(jp2Coord_img);
                              sendCoordinatesToParent(
                                  Math.round(jp2Coord_img[0]),
                                  Math.round(jp2Coord_img[1]),
                                  Math.round(bfiX_for_H),
                                  Math.round(bfiY_for_H),
                                  'coordinate_click'
                              );
                          }
                      }
                  } catch (e) {
                      console.error("Error in BFI map click handler:", e);
                  }
              });

              bfiOlMap.on('moveend', function() {
                  if (syncEnabled && !isUpdatingFromSync && olMap && view && (isSplitView || !jp2IsFullscreen)) {
                      syncJP2ToBFI();
                  }
              });

              // Custom wheel handler - let sync handle JP2 updates
              bfiOlMap.on('wheel', function(event) {
                  event.preventDefault();

                  const bfi_ol_coord = bfiOlMap.getEventCoordinate(event.originalEvent);
                  const currentBfiResolution = bfiView.getResolution();
                  const zoomFactor = 0.9;
                  let newBfiResolution;

                  if (event.originalEvent.deltaY < 0) {
                      newBfiResolution = currentBfiResolution / zoomFactor;
                  } else {
                      newBfiResolution = currentBfiResolution * zoomFactor;
                  }

                  newBfiResolution = Math.max(bfiView.getMinResolution(), Math.min(bfiView.getMaxResolution(), newBfiResolution));

                  if (Math.abs(newBfiResolution - currentBfiResolution) > 1e-9) {
                      bfiView.animate({
                          resolution: newBfiResolution,
                          anchor: bfi_ol_coord,
                          duration: 150,
                          easing: ol.easing.easeOut
                      });
                  }
                  // JP2 will be synced automatically via the moveend event
              });
              /*
              // Custom wheel handler to zoom the JP2 map
              bfiOlMap.on('wheel', function(event) {
                  event.preventDefault();

                  const bfi_ol_coord = bfiOlMap.getEventCoordinate(event.originalEvent);
                  const bfi_nat_coord = [bfi_ol_coord[0], bfiNaturalHeight - bfi_ol_coord[1]]; // Convert to natural BFI coords

                  const jp2AnchorImg = getJP2CoordsFromBFInat(bfi_nat_coord[0], bfi_nat_coord[1]);
                  if (!jp2AnchorImg) return;

                  const olAnchor = [jp2AnchorImg[0], -jp2AnchorImg[1]];

                  const currentResolution = view.getResolution();
                  const zoomFactor = 1.2;
                  let newResolution;

                  if (event.originalEvent.deltaY < 0) { // zoom in
                      newResolution = currentResolution / zoomFactor;
                  } else { // zoom out
                      newResolution = currentResolution * zoomFactor;
                  }

                  const maxResolution = view.getMaxResolution(); // Get max zoom for JP2
                  const minResolution = view.getMinResolution(); // Get min zoom for JP2
                  newResolution = Math.max(minResolution, Math.min(maxResolution, newResolution)); // Clamp new resolution

                  if (Math.abs(newResolution - currentResolution) > 1e-9) {
                       view.animate({
                          resolution: newResolution,
                          anchor: olAnchor,
                          duration: 150,
                          easing: ol.easing.easeOut
                      });
                  }

                  // --- BFI Map Zoom ---
                  const currentBfiResolution = bfiView.getResolution();
                  let newBfiResolution;

                  if (event.originalEvent.deltaY < 0) { // zoom in
                      newBfiResolution = currentBfiResolution / zoomFactor;
                  } else { // zoom out
                      newBfiResolution = currentBfiResolution * zoomFactor;
                  }

                  // Clamp BFI resolution to its min/max allowed values
                  newBfiResolution = Math.max(bfiView.getMinResolution(), Math.min(bfiView.getMaxResolution(), newBfiResolution));

                  if (Math.abs(newBfiResolution - currentBfiResolution) > 1e-9) {
                      bfiView.animate({
                          resolution: newBfiResolution,
                          anchor: bfi_ol_coord, // Anchor at the mouse position on the BFI map
                          duration: 150,
                          easing: ol.easing.easeOut
                      });
                  }
              });
              */

          // New function to draw markers on the BFI OpenLayers map
          
          // Start RGB rendering for BFI if needed
          startBFIRGBRendering();

      }


              // --- View Mode Toggle ---
              function toggleViewMode() {
                  jp2IsFullscreen = !jp2IsFullscreen;

                  // The BFI view is now always the OpenLayers map.
                  // We just toggle the CSS classes on the containers.
                  document.getElementById('bfi_ol_map').style.display = 'block'; // Ensure OL map is visible
                  document.getElementById('bfi_thumbnail_img').style.display = 'none'; // Ensure img tag is hidden
                  // bfiThumbOverlay.style.pointerEvents = 'none'; // Already set globally in DOMContentLoaded

                  if (jp2IsFullscreen) { // Switching to JP2 Fullscreen
                      mapElement.classList.remove('thumbnail-mode');
                      bfiThumbnailContainer.classList.remove('fullscreen-mode');
                      switchViewBtn.textContent = 'View BFI Fullscreen';
                      splitViewBtn.style.display = 'none';
                  } else { // Switching to BFI Fullscreen
                      mapElement.classList.add('thumbnail-mode');
                      bfiThumbnailContainer.classList.add('fullscreen-mode');
                      switchViewBtn.textContent = 'View JP2 Fullscreen';
                      splitViewBtn.style.display = 'inline-block';
                  }
                  // Update sizes and fit views after DOM changes have rendered
                  requestAnimationFrame(() => {
                      requestAnimationFrame(() => {
                          if (olMap) {
                              olMap.updateSize();
                              // Always fit JP2 map to its current container size
                              if(jp2IsFullscreen && view && view.getProjection() && view.getProjection().getExtent()) {
                                  try {
                                      view.fit(view.getProjection().getExtent(), {
                                          size: olMap.getSize(),
                                          constrainResolution: false,
                                          nearest: true,
                                          duration: 0
                                      });
                                  }
                                  catch (e) { console.error("Error refitting JP2 view:", e); }
                              }
                          }

                          if (bfiOlMap) {
                              bfiOlMap.updateSize();
                              // Always fit BFI map to its current container size
                              if (!jp2IsFullscreen && bfiView && bfiView.getProjection() && bfiView.getProjection().getExtent()) { // Check if BFI view is valid
                                  try {
                                      bfiView.fit(bfiView.getProjection().getExtent(), {
                                          size: bfiOlMap.getSize(),
                                          constrainResolution: false,
                                          nearest: true,
                                          duration: 0
                                      });
                                      // Apply zoom adjustment for BFI when it goes fullscreen
                                      if (!jp2IsFullscreen) { // If BFI is now fullscreen (JP2 is thumbnail)
                                          const currentBfiResolution = bfiView.getResolution();
                                          bfiView.setResolution(currentBfiResolution / 2.5); // Apply the specified factor (zoom in more)
                                      }
                                  }
                                  catch (e) { console.error("Error refitting BFI view:", e); }
                              }
                          }
                          updateBFIViewRectangle();
                          placeTestMarkers();
                      });
                  });
              }
              switchViewBtn.addEventListener('click', toggleViewMode);

              // --- Initialization on DOMContentLoaded ---
              window.addEventListener('DOMContentLoaded', () => {
                  document.getElementById('splitViewBtn').addEventListener('click', toggleSplitView);

                  // Set initial view state: JP2 is fullscreen, BFI is an OL thumbnail (but always an OL map).
                  // Ensure BFI OL map is visible and img tag is hidden from the start.
                  document.getElementById('bfi_ol_map').style.display = 'block';
                  document.getElementById('bfi_thumbnail_img').style.display = 'none';
                  bfiThumbOverlay.style.pointerEvents = 'none';

                  // Populate Biosample ID Dropdown
                  if (availableBiosampleIds && availableBiosampleIds.length > 0) {
                      availableBiosampleIds.forEach(id => {
                          const option = document.createElement('option');
                          option.value = String(id); // Ensure value is string
                          option.textContent = String(id);
                          if (String(id) === String(currentBiosampleId)) {
                              option.selected = true;
                          }
                          biosampleIdSelect.appendChild(option);
                      });
                       if (availableBiosampleIds.length <= 1) {
                          // biosampleIdSelect.disabled = true; // Optional: disable if only one choice
                      }
                  } else {
                       const option = document.createElement('option');
                       option.textContent = "N/A";
                       option.disabled = true;
                       biosampleIdSelect.appendChild(option);
                       biosampleIdSelect.disabled = true;
                  }


                  // Populate Slice Number Dropdown
                  if (availableSliceNumbers && availableSliceNumbers.length > 0) {
                      availableSliceNumbers.forEach(num => {
                          const option = document.createElement('option');
                          const numStr = String(num); // Ensure value is string
                          option.value = numStr;
                          option.textContent = numStr;
                          if (numStr === String(currentSliceNumber)) {
                              option.selected = true;
                          }
                          sliceNumberSelect.appendChild(option);
                      });
                  } else {
                      const option = document.createElement('option');
                      option.textContent = "No slices";
                      option.disabled = true;
                      sliceNumberSelect.appendChild(option);
                      sliceNumberSelect.disabled = true;
                  }

                  // Event Listener for navigation
                  function handleSelectionChange() {
                      const selectedBiosampleId = biosampleIdSelect.value;
                      const selectedSliceNumber = sliceNumberSelect.value;

                      if (!selectedBiosampleId || !selectedSliceNumber || sliceNumberSelect.disabled || !viewerUrlTemplate) {
                          console.warn("Cannot navigate: Invalid selection or missing URL template.");
                          return;
                      }

                      // Only navigate if selection differs from current
                      if (selectedBiosampleId === String(currentBiosampleId) && selectedSliceNumber === String(currentSliceNumber)) {
                          return;
                      }

                      // Construct the new URL to include '/split/' as requested
                      let newUrl = viewerUrlTemplate.replace('/viewer/', '/viewer/split/')
                                                    .replace('__BID__', selectedBiosampleId).replace('__SID__', selectedSliceNumber);
                      window.location.href = newUrl;
                  }

                  biosampleIdSelect.addEventListener('change', handleSelectionChange);
                  sliceNumberSelect.addEventListener('change', handleSelectionChange);

                  document.getElementById('jp2ImageSelect').addEventListener('change', function() {
                    const selectedValue = this.value;
                    if (selectedValue === 'nissl') {
                        updateJP2Image('nissl');
                    } else {
                        updateJP2Image('original');
                    }
                });
                
                document.getElementById('bfiImageSelect').addEventListener('change', function() {
                    const selectedValue = this.value;
                    if (selectedValue === 'mri') {
                        updateBFIImage('mri');
                    } else {
                        updateBFIImage('original');
                    }
                });

                // Navigation and RGB Control Panel Toggle
                const rgbControlBtn = document.getElementById('rgbControlBtn');
                const rgbControlPanel = document.getElementById('rgbControlPanel');
                let isRGBPanelVisible = false;

                rgbControlBtn.addEventListener('click', function() {
                    isRGBPanelVisible = !isRGBPanelVisible;
                    
                    if (isRGBPanelVisible) {
                        rgbControlPanel.classList.add('visible');
                        rgbControlBtn.classList.add('active');
                    } else {
                        rgbControlPanel.classList.remove('visible');
                        rgbControlBtn.classList.remove('active');
                    }
                });

                // RGB opacity slider event listeners
                ['r', 'g', 'b'].forEach(channel => {
                    const jp2Slider = document.getElementById(`jp2-${channel}-slider`);
                    const jp2ValueDisplay = document.getElementById(`jp2-${channel}-value`);
                    
                    jp2Slider.addEventListener('input', function() {
                        const value = this.value / 100;
                        jp2RGBOpacity[channel] = value;
                        jp2ValueDisplay.textContent = this.value + '%';
                        applyJP2RGBFilter();
                    });

                    const bfiSlider = document.getElementById(`bfi-${channel}-slider`);
                    const bfiValueDisplay = document.getElementById(`bfi-${channel}-value`);
                    
                    bfiSlider.addEventListener('input', function() {
                        const value = this.value / 100;
                        bfiRGBOpacity[channel] = value;
                        bfiValueDisplay.textContent = this.value + '%';
                        console.log(`BFI ${channel.toUpperCase()} changed to:`, value);
                        applyBFIRGBFilter();
                    });

                    // Combined RGB controls - affects both images simultaneously
                    const combinedSlider = document.getElementById(`combined-${channel}-slider`);
                    const combinedValueDisplay = document.getElementById(`combined-${channel}-value`);
                    
                    combinedSlider.addEventListener('input', function() {
                        const value = this.value / 100;
                        
                        // Update both JP2 and BFI opacity values
                        jp2RGBOpacity[channel] = value;
                        bfiRGBOpacity[channel] = value;
                        
                        // Update all displays
                        combinedValueDisplay.textContent = this.value + '%';
                        jp2ValueDisplay.textContent = this.value + '%';
                        bfiValueDisplay.textContent = this.value + '%';
                        
                        // Update all sliders
                        jp2Slider.value = this.value;
                        bfiSlider.value = this.value;
                        
                        // Apply filters to both images
                        applyJP2RGBFilter();
                        applyBFIRGBFilter();
                    });
                });

                // Gamma slider event listeners
                const jp2GammaSlider = document.getElementById('jp2-gamma-slider');
                const jp2GammaValue = document.getElementById('jp2-gamma-value');
                
                jp2GammaSlider.addEventListener('input', function() {
                    jp2Gamma = this.value / 100; // Convert range 10-300 to 0.1-3.0
                    jp2GammaValue.textContent = jp2Gamma.toFixed(1);
                    applyJP2RGBFilter();
                });

                const bfiGammaSlider = document.getElementById('bfi-gamma-slider');
                const bfiGammaValue = document.getElementById('bfi-gamma-value');
                
                bfiGammaSlider.addEventListener('input', function() {
                    bfiGamma = this.value / 100; // Convert range 10-300 to 0.1-3.0
                    bfiGammaValue.textContent = bfiGamma.toFixed(1);
                    console.log('BFI gamma changed to:', bfiGamma);
                    applyBFIRGBFilter();
                });

                const combinedGammaSlider = document.getElementById('combined-gamma-slider');
                const combinedGammaValue = document.getElementById('combined-gamma-value');
                
                combinedGammaSlider.addEventListener('input', function() {
                    const gammaVal = this.value / 100; // Convert range 10-300 to 0.1-3.0
                    jp2Gamma = gammaVal;
                    bfiGamma = gammaVal;
                    
                    // Update all displays
                    combinedGammaValue.textContent = gammaVal.toFixed(1);
                    jp2GammaValue.textContent = gammaVal.toFixed(1);
                    bfiGammaValue.textContent = gammaVal.toFixed(1);
                    
                    // Update all sliders
                    jp2GammaSlider.value = this.value;
                    bfiGammaSlider.value = this.value;
                    
                    // Apply filters to both images
                    applyJP2RGBFilter();
                    applyBFIRGBFilter();
                });

                // Reset functions
                window.resetJP2RGB = function() {
                    ['r', 'g', 'b'].forEach(channel => {
                        jp2RGBOpacity[channel] = 1;
                        document.getElementById(`jp2-${channel}-slider`).value = 100;
                        document.getElementById(`jp2-${channel}-value`).textContent = '100%';
                    });
                    // Reset gamma
                    jp2Gamma = 1.0;
                    document.getElementById('jp2-gamma-slider').value = 100;
                    document.getElementById('jp2-gamma-value').textContent = '1.0';
                    applyJP2RGBFilter();
                };

                window.resetBFIRGB = function() {
                    ['r', 'g', 'b'].forEach(channel => {
                        bfiRGBOpacity[channel] = 1;
                        document.getElementById(`bfi-${channel}-slider`).value = 100;
                        document.getElementById(`bfi-${channel}-value`).textContent = '100%';
                    });
                    // Reset gamma
                    bfiGamma = 1.0;
                    document.getElementById('bfi-gamma-slider').value = 100;
                    document.getElementById('bfi-gamma-value').textContent = '1.0';
                    applyBFIRGBFilter();
                };

                window.resetAllRGB = function() {
                    ['r', 'g', 'b'].forEach(channel => {
                        jp2RGBOpacity[channel] = 1;
                        bfiRGBOpacity[channel] = 1;
                        
                        // Update all sliders and values
                        document.getElementById(`jp2-${channel}-slider`).value = 100;
                        document.getElementById(`bfi-${channel}-slider`).value = 100;
                        document.getElementById(`combined-${channel}-slider`).value = 100;
                        
                        document.getElementById(`jp2-${channel}-value`).textContent = '100%';
                        document.getElementById(`bfi-${channel}-value`).textContent = '100%';
                        document.getElementById(`combined-${channel}-value`).textContent = '100%';
                    });
                    
                    // Reset gamma for both images
                    jp2Gamma = 1.0;
                    bfiGamma = 1.0;
                    document.getElementById('jp2-gamma-slider').value = 100;
                    document.getElementById('bfi-gamma-slider').value = 100;
                    document.getElementById('combined-gamma-slider').value = 100;
                    document.getElementById('jp2-gamma-value').textContent = '1.0';
                    document.getElementById('bfi-gamma-value').textContent = '1.0';
                    document.getElementById('combined-gamma-value').textContent = '1.0';
                    
                    applyJP2RGBFilter();
                    applyBFIRGBFilter();
                };


                  // Initialize matrices
                  if (H_jp2_to_bfi) {
                       H_bfi_to_jp2 = invertAffineMatrix(H_jp2_to_bfi);
                      if (!H_bfi_to_jp2) {
                          console.error("Failed to invert H_jp2_to_bfi matrix! BFI interactions depending on this may fail.");
                          if(bfiViewRect) bfiViewRect.style.display = 'none'; // Old DOM element
                      } else {
                          // console.log("H_bfi_to_jp2 (inverted matrix):", JSON.parse(JSON.stringify(H_bfi_to_jp2)));
                      }
                  } else {
                       console.error("H_jp2_to_bfi matrix is not available from backend. BFI interactions will be disabled or incorrect.");
                       if(bfiViewRect) bfiViewRect.style.display = 'none';
                  }

                  if (!bfiImageUrl || (typeof bfiImageUrl === 'string' && bfiImageUrl.startsWith('images_data'))) {
                      // console.warn("bfiImageUrl ('" + bfiImageUrl + "') might be a placeholder or relative path. Ensure it's an absolute or correctly resolved path accessible by the browser.");
                  }
                  if (!isSplitView) {
                    toggleSplitView();
                }

                  initializeJP2Map();
                  loadBFIThumbnail();
              });
    </script>
  </body>
</html>